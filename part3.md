# Разработка веб-сервисов на Golang. Часть 3:

- week 1, Структура приложения
- week 2, Проектирование API
- week 3, GraphQL
- week 4, Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов

## part 3, week 1 (09)

Структура приложения
[Код, домашки, литература](week_09/materials.zip) https://cloud.mail.ru/public/GzJG/nccMpqdzQ

### Структурируем приложение - 1 (вводная)

На примере цельного приложения `photolist` рассмотрим несколько важных тем.

### Структурируем приложение - 2 (описание прототипа и его проблем)

- [main](week_09/basic_main.go)
- [photos](week_09/basic_photos.go)

Начнем с прототипа, сляпанного из спагетти-кода. Чтобы сразу нарисовать целостную картину и декларировать проблемы, решаемые в следующих лекциях.

Главная программа, веб-сервис и модуль с утилитами для фоток.
Фунциональность: одна страница, на которой мы можем выбрать фотку для upload и видеть превьюхи уже загруженных фоток.

Три хандлера: `/`-list, `/upload`-upload, `/images/`-static_files.

Проблемы: глобальные переменные, не-потоко-безопасные; постоянный парсинг шаблона; нет авторизации;
файлы на диске сервера (вместо абстрактного хранилища);
вычитывание файлов для каждой превью, прямо при обработке запроса (должно быть через очередь, в воркерах);
код плохо разбит на модули и сложно тестировать.

### Структурируем приложение - 3 (распил на модули)

- [handlers](week_09/storage_handlers.go)
- [main](week_09/storage_main.go)
- [photos](week_09/storage_photos.go)
- [storage](week_09/storage_storage.go)
- [templates](week_09/storage_templates.go)

Разделение приложения на модули (файлы go).
На части разделился main: handlers, storage, templates.

При старте программы создается структура с инициализацией полей Storage, Templates.
Хендлеры страниц реализованы как методы этой структуры и пользуются этими полями, отвечающими некоторому нашему интерфейсу.

Шаблон теперь парсится один раз, при старте программы. Уже лучше.

Функциональность немного абстрагирована, разбита на модули и может быть протестирована.

### Структурируем приложение - 4 (add DB)

- [main](week_09/db_main.go)
- [db_init.sql](week_09/db_db_init.sql)
- [storage](week_09/db_storage.go)

Добавим БД `mysql` для поддержки постоянного хранения метаданных (списка загруженных файлов).
При создании структуры с данными сервиса мы кладем туда реф. на хранилище с тем-же интерфейсом но использующее БД.

Обсудили еще раз проблему глобальных переменных и их инициализации внутри фунции с помощью конструкции `db := createConnect(...)`:
тут не инициализируется глобальная переменная, тут создается новая локальная переменная.

### Тестируем комплексное приложение - 1 (sqlmock)

- [storage_test](week_09/db_storage_test.go)

Как тестировать логику, завязанную на запросы к БД.
Использовать драйвер к `sql.DB`: go-sqlmock.
Мокать запросы к БД.

### Тестируем комплексное приложение - 2 (gomock)

- [handlers](week_09/test_handlers.go)
- [handler_test](week_09/test_handler_test.go)

Как тестировать хендлер веб-страницы на примере `List`.
Сначала посчитали, сколько и каких кейсов тестирования надо: получение фоток (ок, ерр), заполнение шаблона (ок, ерр).
Сообразили, что нужен mock хранилища.

Поэтому: в данных сервиса реф. на хранилище меняем на реф. на интерфейс.
Потом в тесте подкладываем мок хранилища в код сервера и тестируем разные случаи.

По интерфейсу кодогенератор сделает обвязку, `mockgen ...`
В тестах используем её.

Upload handler будем мокать и тестировать тогда, когда абстрагируем хранилище и задействуем облако.

NB: интерфейс должен объявляться в том месте, где будет использоваться (где наиболее общий код).
Кроме случаев с интерфейсами общего назначения.
Почему? Направление зависимости в обратную сторону.
Реализация не должна объявлять этот интерфейс, просто реализовать заявленные методы.

### Авторизация и пароли - 1 (auth MVP)

- [db_init.sql](week_09/auth_db_init.sql)
- [templates](week_09/auth_templates.go)
- [main](week_09/auth_main.go)
- [session](week_09/auth_session.go)
- [index](week_09/auth_index.go)
- [user](week_09/auth_user.go)

Базовая версия подсистемы идентификации-авторизации.

Таблица с сессиями, таблица с пользователями. Для просмотра БД использует веб-морду Adminer.
Регистрация нового пользователя, выдача ему сессии-куки.

Появилась структура UserHandler.
Появились урлы (и хендлеры) login, logout, reg.
Завернул все урлы в AuthMiddleware через `/`.

Потом добавил статику `/images/`, получилось, что картинки отдаются мимо авторизации, ибо при маршрутизации сначала проверится
самый длинный путь (images) и дернется его обработчик, без авторизации.

Мидлварь авторизации проверяет, надо ли требовать наличия пользователя на данной странице.
На некоторых страницах пользователя может и не быть (e.g. регистрация нового пользователя).

Мапка, где значения это пустые структуры `struct{}`, не требует памяти под значения. Это set ключей.
Далее мидлварь достает сессию из БД или создает новую или вываливается с ошибкой.
Сессия добавляется в контекст и дергается downstream обработчик запроса, с передачей ему контекста.

Проверка наличия сессии в контексте используется в главной странице, при решении, куда направить пользователя: на страницу логина или в его ленту.

Обработка логина/регистрации, через БД.
Тонкости проверки/хранения пароля в след.видео.

### Авторизация и пароли - 2 (password hash)

- [user](week_09/auth_user.go)
- [pass](week_09/hashing_pass.go)

Как хешировать и хранить пароль.
Рандомная соль + функция хеширования.
Для одинаковых паролей получаем разные хеши.
Argon2 хорошая функция хеширования.

`hashedPass := argon2.IDKey([]byte(plainPassword), []byte(salt), 1, 64*1024, 4, 32)`

Пример с разными реализациями хеширования пароля.
Бенчмарк по скорости генерации пароля: чем медленнее, тем лучше, затрудняет брут-форс атаки.
Чем больше жрет памяти, тем лучше, труднее запустить на акселераторе.

### CSRF-токены (JWT для защиты от CSRF)

- [hash_token](week_09/csrf_token_hash_token.go)
- [crypt_token](week_09/csrf_token_crypt_token.go)
- [jwt_token](week_09/csrf_token_jwt_token.go)

JSON Web Tokens: безопасная передача токенов кросс-сайт. JWT.IO для проверки и де/кодирования JWT.
JWT в качестве CSRF-токенов.
Данные в токене открыты и доступны для просмотра. Защищены от изменения.

CSRF: Cross-Site Request Forgery.

Хеш токен просто хеширует массив байт, в котором зашиты sessID, userID. Потом туда добавляется tokenExpTime.

В крипто токене: структура с тремя полями превращается в json и этот текст шифруется.
Требуется защить эти данные от подделок (не от кражи).

JWT предлагает для защиты: контейнер с подписью. Данные открыты, но для их подмены надо как-то узнать ключ, которым подписан токен.
Этот ключ создается и используется на сервере, должен быть одноразовым и защищенным.

JWT токен состит из трех частей:
- заголовок: алгоритм, тип токена
- данные: json с нашими айдишками и временем жизни и временем выдачи токена
- подпись

Игрушечный пример со скользящими ключами, меняемыми на основе времени выдачи/устаревания.

### Сессии - 1 (рефакторинг сессий)

- [main](week_09/jwt_sess_main.go)
- [session_common](week_09/jwt_sess_session_common.go)
- [session_db](week_09/jwt_sess_session_db.go)
- [user](week_09/jwt_sess_user.go)

Рефакторинг кода сессий, с целью абстрагироваться от реализации.
С тем, чтобы потом воткнуть туда JWT токены.

Добавил менеджер сессий, класс с фабрикой.
Менеджер сессий добавлен как поле в структуру хендлеров страниц.
Используется в мидлварь авторизации и в обработке юзера.

Интерфейс менеджера сессий.

Реализация менеджера сессий на БД. Удаление всех сессий пользователя.

Создание пользователя и логин. Смена пароля пользователя.
Добавление атрибута `ver` к данным пользователя. Версионированность.

### Сессии - 2 (stateful vs stateless sessions)

Проблемы JWT в роли замены sessionID.

Аутентификация, stateful сессия, хранится в БД.
Недостаток: надо хранить в БД.
Преимущества: удобно, всё под рукой, любую сессию можно закрыть в любой момент.

Stateless сессия, на токенах (JWT).
В токене хранится не сессия а сразу (UserID, UserRoles).
В БД хранится только инфа по пользователю, сессия не нужна.

Проблемы.
Трудно отозвать сессию, только перевыпустив токен с датой устаревания в прошлом.
При этом умрут все сесии.
Нет надежного logout, при смене пароля не могу закрыть устаревшие сессии.
Нет полного списка сессий, нельзя видеть, кто еще (где) ходит от моего пользователя.

В целом, при отказе от сессий, либо трудно/невозможно выкинуть злоумышленника, либо пользователя постоянно выкидывает и ему надо перелогиниваться.

Как вариант, хранить в БД профиль пользователя а в токене передавать только (userID, userVersion).
Тогда, в профиле можно держать версию данных пользователя и испльзовать ее как признак смены сессии.
Такое, половинчатое решение, все равно ходим в БД за профилем (вместо хождения за сессией); все равно нет данных по каждой сессии.

https://www.google.com/search?q=stateless+sessions+JWT+problems+&client=safari&rls=en&ei=y0YgY56MGvCvrgSS6KewBA&ved=0ahUKEwjenfaBtJH6AhXwl4sKHRL0CUYQ4dUDCA0&uact=5&oq=stateless+sessions+JWT+problems+&gs_lcp=Cgdnd3Mtd2l6EAMyBQghEKABOgoIABBHENYEELADOgUIABCiBDoHCAAQHhCiBEoECEEYAEoECEYYAFCfDVjkOmCgPmgDcAF4AIABVIgB0wWSAQIxMZgBAKABAcgBCMABAQ&sclient=gws-wiz

### Сессии - 3 (JWT session)

- [main](week_09/jwt_sess_main.go)
- [session_jwt](week_09/jwt_sess_session_jwt.go)
- [session_jwt_ver](week_09/jwt_sess_session_jwt_ver.go)

Реализация сессий на JWT в двух вариантах: беззащитном, с версионированием профиля пользователя.
Начинается с менеджера сессий: `sm := NewSessionsJWT("golangcourseSessionSecret")` vs `sm := NewSessionsJWTVer("golangcourseSessionSecret", db)`

Сессия без базы экономит один поход в БД на каждый запрос.
Токен содержит только userID и стандартные поля.
Сессия пишется только в куку.
На удалении сессий мы можем только поставить устаревание куки и ничего не можем сделать с другими сессиями.

N.B. в реализации с сессиями в БД, при удалении сесии дропались записи сессий в БД. Что выкидывало пользователей на других сессиях.
Что хорошо для безопасности.
Без БД эта функциональность недоступна.

Что продемонстрировано сменой пароля к сайту в одном браузере и продолжающей работать сессией в другом браузере.

Реализация сессий на токенах (куках) с версионированием профиля пользователя.
Есть поход в БД за профилем, на каждый запрос.
В токен добавлено поле `ver`.
При проверке сессии нужен поход в БД за профилем пользователя.
После чего проверяется версия, наряду с другими проверками.

При удалении сессий логика не поменялась, удаляется только кука с токеном (userID).
Т.е. выкидывать других пользователей будет только при редактировании профиля (изменении пароля, etc.)

Вопрос: ну и зачем мы так стремимся отказаться от хранилища сессий?
Рекомендует не отказываться от stateful (persistent) session до тех пор, пока выбора не останется.

## part 3, week 2 (10)

Проектирование API
[Код, домашки, литература](week_10/materials.zip) https://cloud.mail.ru/public/PME6/Mqp8mFsPK

### Oauth - 1 (демонстрация получения данных от провайдера oauth)

- [main](week_10/oauth_main.go)

Как реализовать в своем приложении аутентификацию при помощи протокола OAuth.
Демонстрация получения данных пользователя от провайдера OAuth.
Пользователю дают возможность использовать провайдера OAuth (сайт на котором у п. есть учётка) для
выдачи своих данных (userID, ...) сайту photolist.

Надо зарегать свое приложение на специальной странице VK, получив идентификатор и секретный ключ.
При настройке можно указать, к каким данным пользователя сможет обращаться приложение: друзья, фоточки, ...

При нажатии на кнопку "авторизоваться" в приложении, идет обращение к VK с запросом подтверждения "вы уверены ...?".
После подтверждения, идет редирект на страницу приложения, где демонстрируется успешность доступа к данным пользователя VK.
Страница приложения получила от VK код, по которому, дернув API VK, приложение получает токены и данные пользователя.
Теперь приложение может создать сессию для пользователя.

N.B. провайдер спрашивает у пользователя подтверждение только один раз. Потом аутентификация будет происходить прозрачно.

Пакеты `oauth2`, `oauth2/vk`.
В константах зашиты идентификатор приложения, ключ доступа к VK, урл для получения токена, урл для получения данных о пользователе.

### Oauth - 2 (photolist oauth)

- [user](week_10/photolist_oauth_user.go)

Как в игрушечном приложении был добавлен метод аутентификации oauth.

Порефакторил метод регистрации, вынес работу с БД в отдельный метод.
При регистрации нового пользователя, первым делом проверяется наличие такого логина.
Если есть, возвращается его id и ошибка errUserExists.
Это работает для регистрации через VK.
Неважно, как был зареган пользователь, в БД надо внести запись.

Пользователь в VK может не иметь почты, поэтому есть код проверки и использования vkid вместо почты, в качестве логина.
Пароль генерит случайный, для записи в БД. Поэтому войти в приложение с паролем, мимо VK, не получится.

### Немного рефакторинга - 1 (photolist frontend)

- [list.html](week_10/photolist_frontend_list.html)
- [list.js](week_10/photolist_frontend_list.js)
- [templates](week_10/photolist_frontend_templates.go)
- [handlers](week_10/photolist_frontend_handlers.go)
- [storage](week_10/photolist_frontend_storage.go)

Приукрасил страницы аппы, используя bootsrap. Добавил CSRF токены.
Появилась директория `static`, `templates`.

В метатеге html появился `csrf-token`. Который прокидывается в заголовки запроса.

Смотри `rateCommentToggle` для понимания работы лайков.

В бд новая таблица user_photo_likes(photo_id, user_id).
При выводе фоток делает left_join фоток с лайками, с фильтром по пользователю.
Обработка null при выборе лайкнутых фоток.

Обработка записи лайка в БД, handler `Rate`.
Добавить или удалить запись в кросс-таблицу user_photos_likes и обновить количество лайков в таблице photos.
Хотя рейтинг можно считать на лету из кросс-таблицы, экономнее хранить агрегат в таблице фоток.

hot reload: перезапуск сервиса при изменении кода ...

### Немного рефакторинга - 2 (photolist frontend, air)

- [air.conf](week_10/photolist_frontend_air.conf)
- [main](week_10/photolist_frontend_main.go)
- [templates](week_10/photolist_frontend_templates.go)

live reload, hot reload.

`go run --tags=dev .`

`cosmtrek/air` - live-reloading wrapper.

`air -c air.conf`

Поменял подключение шаблонов, стал использовать `vfstemplate` из `shurcool/httpfs/html/`.

### Немного рефакторинга - 3 (static assets)

- [templates](week_10/photolist_frontend_templates.go)
- [assets](week_10/photolist_frontend_assets.go)
- [assets_gen](week_10/photolist_frontend_assets_gen.go)
- [main](week_10/photolist_frontend_main.go)

Встраивание статики в наш бинарник, чтобы фавиконки и прочее отдавать из бинарника а не из внешних файлов.
Проблема: air запускает бинарник из временного каталога, в котором нет нашего хранилища стат. файлов.
Решение: либо абсолютный путь к хранилищу, либо паковать внешние файлы вместе с бинарником.

Resources embedding.

На диске лежит два бинарника: dev, release. dev собирается без embedding, release собирается с embedding.
Ибо внутренние ресурсы программы лучше паковать внутрь программы (до некоторых пор).

Пакуются они через превращение в файлы go (`assets_vfsdata.go`), где ресурсы это слайсы байт.
Очевидно, такое решение годится только для маленьких ресурсов.

В файле ресурсов есть тег `// +build !dev`
чтобы сборка dev пользовалась внешними ресурсами.

В файле ассетов есть тег `// +build dev`. Так определяется, какой файл вливать в бинарник при сборке разных версий.

Генерация ресурсов выполняется очень запутанной процедурой, с использованием тегов `// +build ignore`, `// +build !dev`
в разных файлах.

Запускается генерация файла ресурсов через `go generate --tags=dev`

Не надо встраивать конфиги в бинарник (спасибо кэп).

Не надо встраивать шаблоны страниц сайта в бинарь, если разработка фронта отделена от разработки бэка.
Надо сделать hot-reload шаблонов в аппе, считывая их из хранилища.

### Проектирование API - 1 (форматы, документация)

Веб-API
- Согласованность, все запросы-ответы в едином формате, стиле.
- Расширяемость, нет проблем с добавлением атрибутов, параметров, сущноcтей.
- Документация, должна быть, актуальная, автогенерированная + вручную написанные блоки.

Пример разных форматов:
- Список безымянных значений из разных доменов: очень плохо, нет структуры, нет типизации, нет самодокументируемости.
    Нет возможности удалить значение.
- Список словарей, лучше, но не сильно. Метаданные для ответа в целом вставить некуда, расширение структуры будет выглядеть чужеродно.
- Словарь вложенной структуры. Нелохо. Если разделить на метаданные и данные, будет отлично.

```json
{
    "meta": {},
    "data": {}
}
```

Никогда не отдавайте HTTP-status 200 если была ошибка.
Отдавайте 400 или 500.

Накрайняк, если хотите отделить транспорт от логики,
можно отдать HTTP-status 200 если была ошибка логики, но в ответе должно быть стандартное поле `status` с кодом ошибки.
Логировать эту ошибку надо через доп. заголовок. Т.е. код ошибки логики дублируется в заголовке и в теле ответа.

Документируйте публичные API в коде, генерируйте документацию. Используйте Swagger.
- schema-first
- from comments

Или protobuf + grpc, schema-first подход, когда в proto-файле всё описано.

Или GraphQL.

### Проектирование API - 2 (проектирование формата URL)

Какие URL следует использовать (формат), какие -- нет.
От cgi-bin программ, через php модули, через контроллеры запросов, через человеко-читаемые-урл, через REST HTTP verbs,
до `POST /api/v1/jrpc + JSON-RPC` или `POST /api/v1/gql + GraphQL`.

ЧЧУ: `/api/v1/articles/${slug}`.

Как передавать параметры?
- путь = метод, параметры = параметры. Путь должен однозначно определять сущность, для которой надо получить инфу.
- вариант REST: идентификатор зашивается в путь, `/api/v1/photos/${user_id}`. В Go такое сделать сложновато.
    Для реализации удобнее зашивать идентификатор в последнюю часть пути: `photo/comments/${photo_id}`.

Вот так лучше не надо: `photo/${photo_id}/comments/${comment_id}`, теряется понимание и согласованность.

Рекомендует в пути держать имя метода а параметры в query.
Как вариант, основной параметр идет последним элементом пути.

### Проектирование API - 3

### Проектирование API - 4
### Проектирование API - 5

## part 3, week 3 (11)

GraphQL
[Код, домашки, литература](week_11/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer

## part 3, week 4 (12)

Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов
[Код, домашки, литература](week_12/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer
