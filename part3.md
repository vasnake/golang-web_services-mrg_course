# Разработка веб-сервисов на Golang. Часть 3:

- week 1, Структура приложения
- week 2, Проектирование API
- week 3, GraphQL
- week 4, Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов

## part 3, week 1 (09)

Структура приложения
[Код, домашки, литература](week_09/materials.zip) https://cloud.mail.ru/public/GzJG/nccMpqdzQ

### Структурируем приложение - 1 (вводная)

На примере цельного приложения `photolist` рассмотрим несколько важных тем.

### Структурируем приложение - 2 (описание прототипа и его проблем)

- [main](week_09/basic_main.go)
- [photos](week_09/basic_photos.go)

Начнем с прототипа, сляпанного из спагетти-кода. Чтобы сразу нарисовать целостную картину и декларировать проблемы, решаемые в следующих лекциях.

Главная программа, веб-сервис и модуль с утилитами для фоток.
Фунциональность: одна страница, на которой мы можем выбрать фотку для upload и видеть превьюхи уже загруженных фоток.

Три хандлера: `/`-list, `/upload`-upload, `/images/`-static_files.

Проблемы: глобальные переменные, не-потоко-безопасные; постоянный парсинг шаблона; нет авторизации;
файлы на диске сервера (вместо абстрактного хранилища);
вычитывание файлов для каждой превью, прямо при обработке запроса (должно быть через очередь, в воркерах);
код плохо разбит на модули и сложно тестировать.

### Структурируем приложение - 3 (распил на модули)

- [handlers](week_09/storage_handlers.go)
- [main](week_09/storage_main.go)
- [photos](week_09/storage_photos.go)
- [storage](week_09/storage_storage.go)
- [templates](week_09/storage_templates.go)

Разделение приложения на модули (файлы go).
На части разделился main: handlers, storage, templates.

При старте программы создается структура с инициализацией полей Storage, Templates.
Хендлеры страниц реализованы как методы этой структуры и пользуются этими полями, отвечающими некоторому нашему интерфейсу.

Шаблон теперь парсится один раз, при старте программы. Уже лучше.

Функциональность немного абстрагирована, разбита на модули и может быть протестирована.

### Структурируем приложение - 4 (add DB)

- [main](week_09/db_main.go)
- [db_init.sql](week_09/db_db_init.sql)
- [storage](week_09/db_storage.go)

Добавим БД `mysql` для поддержки постоянного хранения метаданных (списка загруженных файлов).
При создании структуры с данными сервиса мы кладем туда реф. на хранилище с тем-же интерфейсом но использующее БД.

Обсудили еще раз проблему глобальных переменных и их инициализации внутри фунции с помощью конструкции `db := createConnect(...)`:
тут не инициализируется глобальная переменная, тут создается новая локальная переменная.

### Тестируем комплексное приложение - 1 (sqlmock)

- [storage_test](week_09/db_storage_test.go)

Как тестировать логику, завязанную на запросы к БД.
Использовать драйвер к `sql.DB`: go-sqlmock.
Мокать запросы к БД.

### Тестируем комплексное приложение - 2 (gomock)

- [handlers](week_09/test_handlers.go)
- [handler_test](week_09/test_handler_test.go)

Как тестировать хендлер веб-страницы на примере `List`.
Сначала посчитали, сколько и каких кейсов тестирования надо: получение фоток (ок, ерр), заполнение шаблона (ок, ерр).
Сообразили, что нужен mock хранилища.

Поэтому: в данных сервиса реф. на хранилище меняем на реф. на интерфейс.
Потом в тесте подкладываем мок хранилища в код сервера и тестируем разные случаи.

По интерфейсу кодогенератор сделает обвязку, `mockgen ...`
В тестах используем её.

Upload handler будем мокать и тестировать тогда, когда абстрагируем хранилище и задействуем облако.

NB: интерфейс должен объявляться в том месте, где будет использоваться (где наиболее общий код).
Кроме случаев с интерфейсами общего назначения.
Почему? Направление зависимости в обратную сторону.
Реализация не должна объявлять этот интерфейс, просто реализовать заявленные методы.

### Авторизация и пароли - 1 (auth MVP)

- [db_init.sql](week_09/auth_db_init.sql)
- [templates](week_09/auth_templates.go)
- [main](week_09/auth_main.go)
- [session](week_09/auth_session.go)
- [index](week_09/auth_index.go)
- [user](week_09/auth_user.go)

Базовая версия подсистемы идентификации-авторизации.

Таблица с сессиями, таблица с пользователями. Для просмотра БД использует веб-морду Adminer.
Регистрация нового пользователя, выдача ему сессии-куки.

Появилась структура UserHandler.
Появились урлы (и хендлеры) login, logout, reg.
Завернул все урлы в AuthMiddleware через `/`.

Потом добавил статику `/images/`, получилось, что картинки отдаются мимо авторизации, ибо при маршрутизации сначала проверится
самый длинный путь (images) и дернется его обработчик, без авторизации.

Мидлварь авторизации проверяет, надо ли требовать наличия пользователя на данной странице.
На некоторых страницах пользователя может и не быть (e.g. регистрация нового пользователя).

Мапка, где значения это пустые структуры `struct{}`, не требует памяти под значения. Это set ключей.
Далее мидлварь достает сессию из БД или создает новую или вываливается с ошибкой.
Сессия добавляется в контекст и дергается downstream обработчик запроса, с передачей ему контекста.

Проверка наличия сессии в контексте используется в главной странице, при решении, куда направить пользователя: на страницу логина или в его ленту.

Обработка логина/регистрации, через БД.
Тонкости проверки/хранения пароля в след.видео.

### Авторизация и пароли - 2 (password hash)

- [user](week_09/auth_user.go)
- [pass](week_09/hashing_pass.go)

Как хешировать и хранить пароль.
Рандомная соль + функция хеширования.
Для одинаковых паролей получаем разные хеши.
Argon2 хорошая функция хеширования.

`hashedPass := argon2.IDKey([]byte(plainPassword), []byte(salt), 1, 64*1024, 4, 32)`

Пример с разными реализациями хеширования пароля.
Бенчмарк по скорости генерации пароля: чем медленнее, тем лучше, затрудняет брут-форс атаки.
Чем больше жрет памяти, тем лучше, труднее запустить на акселераторе.

### CSRF-токены (JWT для защиты от CSRF)

- [hash_token](week_09/csrf_token_hash_token.go)
- [crypt_token](week_09/csrf_token_crypt_token.go)
- [jwt_token](week_09/csrf_token_jwt_token.go)

JSON Web Tokens: безопасная передача токенов кросс-сайт. JWT.IO для проверки и де/кодирования JWT.
JWT в качестве CSRF-токенов.
Данные в токене открыты и доступны для просмотра. Защищены от изменения.

CSRF: Cross-Site Request Forgery.

Хеш токен просто хеширует массив байт, в котором зашиты sessID, userID. Потом туда добавляется tokenExpTime.

В крипто токене: структура с тремя полями превращается в json и этот текст шифруется.
Требуется защить эти данные от подделок (не от кражи).

JWT предлагает для защиты: контейнер с подписью. Данные открыты, но для их подмены надо как-то узнать ключ, которым подписан токен.
Этот ключ создается и используется на сервере, должен быть одноразовым и защищенным.

JWT токен состит из трех частей:
- заголовок: алгоритм, тип токена
- данные: json с нашими айдишками и временем жизни и временем выдачи токена
- подпись

Игрушечный пример со скользящими ключами, меняемыми на основе времени выдачи/устаревания.

### Сессии - 1 (рефакторинг сессий)

- [main](week_09/jwt_sess_main.go)
- [session_common](week_09/jwt_sess_session_common.go)
- [session_db](week_09/jwt_sess_session_db.go)
- [user](week_09/jwt_sess_user.go)

Рефакторинг кода сессий, с целью абстрагироваться от реализации.
С тем, чтобы потом воткнуть туда JWT токены.

Добавил менеджер сессий, класс с фабрикой.
Менеджер сессий добавлен как поле в структуру хендлеров страниц.
Используется в мидлварь авторизации и в обработке юзера.

Интерфейс менеджера сессий.

Реализация менеджера сессий на БД. Удаление всех сессий пользователя.

Создание пользователя и логин. Смена пароля пользователя.
Добавление атрибута `ver` к данным пользователя. Версионированность.

### Сессии - 2 (stateful vs stateless sessions)

Проблемы JWT в роли замены sessionID.

Аутентификация, stateful сессия, хранится в БД.
Недостаток: надо хранить в БД.
Преимущества: удобно, всё под рукой, любую сессию можно закрыть в любой момент.

Stateless сессия, на токенах (JWT).
В токене хранится не сессия а сразу (UserID, UserRoles).
В БД хранится только инфа по пользователю, сессия не нужна.

Проблемы.
Трудно отозвать сессию, только перевыпустив токен с датой устаревания в прошлом.
При этом умрут все сесии.
Нет надежного logout, при смене пароля не могу закрыть устаревшие сессии.
Нет полного списка сессий, нельзя видеть, кто еще (где) ходит от моего пользователя.

В целом, при отказе от сессий, либо трудно/невозможно выкинуть злоумышленника, либо пользователя постоянно выкидывает и ему надо перелогиниваться.

Как вариант, хранить в БД профиль пользователя а в токене передавать только (userID, userVersion).
Тогда, в профиле можно держать версию данных пользователя и испльзовать ее как признак смены сессии.
Такое, половинчатое решение, все равно ходим в БД за профилем (вместо хождения за сессией); все равно нет данных по каждой сессии.

https://www.google.com/search?q=stateless+sessions+JWT+problems+&client=safari&rls=en&ei=y0YgY56MGvCvrgSS6KewBA&ved=0ahUKEwjenfaBtJH6AhXwl4sKHRL0CUYQ4dUDCA0&uact=5&oq=stateless+sessions+JWT+problems+&gs_lcp=Cgdnd3Mtd2l6EAMyBQghEKABOgoIABBHENYEELADOgUIABCiBDoHCAAQHhCiBEoECEEYAEoECEYYAFCfDVjkOmCgPmgDcAF4AIABVIgB0wWSAQIxMZgBAKABAcgBCMABAQ&sclient=gws-wiz

### Сессии - 3 (JWT session)

- [main](week_09/jwt_sess_main.go)
- [session_jwt](week_09/jwt_sess_session_jwt.go)
- [session_jwt_ver](week_09/jwt_sess_session_jwt_ver.go)

Реализация сессий на JWT в двух вариантах: беззащитном, с версионированием профиля пользователя.
Начинается с менеджера сессий: `sm := NewSessionsJWT("golangcourseSessionSecret")` vs `sm := NewSessionsJWTVer("golangcourseSessionSecret", db)`

Сессия без базы экономит один поход в БД на каждый запрос.
Токен содержит только userID и стандартные поля.
Сессия пишется только в куку.
На удалении сессий мы можем только поставить устаревание куки и ничего не можем сделать с другими сессиями.

N.B. в реализации с сессиями в БД, при удалении сесии дропались записи сессий в БД. Что выкидывало пользователей на других сессиях.
Что хорошо для безопасности.
Без БД эта функциональность недоступна.

Что продемонстрировано сменой пароля к сайту в одном браузере и продолжающей работать сессией в другом браузере.

Реализация сессий на токенах (куках) с версионированием профиля пользователя.
Есть поход в БД за профилем, на каждый запрос.
В токен добавлено поле `ver`.
При проверке сессии нужен поход в БД за профилем пользователя.
После чего проверяется версия, наряду с другими проверками.

При удалении сессий логика не поменялась, удаляется только кука с токеном (userID).
Т.е. выкидывать других пользователей будет только при редактировании профиля (изменении пароля, etc.)

Вопрос: ну и зачем мы так стремимся отказаться от хранилища сессий?
Рекомендует не отказываться от stateful (persistent) session до тех пор, пока выбора не останется.

## part 3, week 2 (10)

Проектирование API
[Код, домашки, литература](week_10/materials.zip) https://cloud.mail.ru/public/PME6/Mqp8mFsPK

### Oauth - 1 (демонстрация получения данных от провайдера oauth)

- [main](week_10/oauth_main.go)

Как реализовать в своем приложении аутентификацию при помощи протокола OAuth.
Демонстрация получения данных пользователя от провайдера OAuth.
Пользователю дают возможность использовать провайдера OAuth (сайт на котором у п. есть учётка) для
выдачи своих данных (userID, ...) сайту photolist.

Надо зарегать свое приложение на специальной странице VK, получив идентификатор и секретный ключ.
При настройке можно указать, к каким данным пользователя сможет обращаться приложение: друзья, фоточки, ...

При нажатии на кнопку "авторизоваться" в приложении, идет обращение к VK с запросом подтверждения "вы уверены ...?".
После подтверждения, идет редирект на страницу приложения, где демонстрируется успешность доступа к данным пользователя VK.
Страница приложения получила от VK код, по которому, дернув API VK, приложение получает токены и данные пользователя.
Теперь приложение может создать сессию для пользователя.

N.B. провайдер спрашивает у пользователя подтверждение только один раз. Потом аутентификация будет происходить прозрачно.

Пакеты `oauth2`, `oauth2/vk`.
В константах зашиты идентификатор приложения, ключ доступа к VK, урл для получения токена, урл для получения данных о пользователе.

### Oauth - 2 (photolist oauth)

- [user](week_10/photolist_oauth_user.go)

Как в игрушечном приложении был добавлен метод аутентификации oauth.

Порефакторил метод регистрации, вынес работу с БД в отдельный метод.
При регистрации нового пользователя, первым делом проверяется наличие такого логина.
Если есть, возвращается его id и ошибка errUserExists.
Это работает для регистрации через VK.
Неважно, как был зареган пользователь, в БД надо внести запись.

Пользователь в VK может не иметь почты, поэтому есть код проверки и использования vkid вместо почты, в качестве логина.
Пароль генерит случайный, для записи в БД. Поэтому войти в приложение с паролем, мимо VK, не получится.

### Немного рефакторинга - 1 (photolist frontend)

- [list.html](week_10/photolist_frontend_list.html)
- [list.js](week_10/photolist_frontend_list.js)
- [templates](week_10/photolist_frontend_templates.go)
- [handlers](week_10/photolist_frontend_handlers.go)
- [storage](week_10/photolist_frontend_storage.go)

Приукрасил страницы аппы, используя bootsrap. Добавил CSRF токены.
Появилась директория `static`, `templates`.

В метатеге html появился `csrf-token`. Который прокидывается в заголовки запроса.

Смотри `rateCommentToggle` для понимания работы лайков.

В бд новая таблица user_photo_likes(photo_id, user_id).
При выводе фоток делает left_join фоток с лайками, с фильтром по пользователю.
Обработка null при выборе лайкнутых фоток.

Обработка записи лайка в БД, handler `Rate`.
Добавить или удалить запись в кросс-таблицу user_photos_likes и обновить количество лайков в таблице photos.
Хотя рейтинг можно считать на лету из кросс-таблицы, экономнее хранить агрегат в таблице фоток.

hot reload: перезапуск сервиса при изменении кода ...

### Немного рефакторинга - 2 (photolist frontend, air)

- [air.conf](week_10/photolist_frontend_air.conf)
- [main](week_10/photolist_frontend_main.go)
- [templates](week_10/photolist_frontend_templates.go)

live reload, hot reload.

`go run --tags=dev .`

`cosmtrek/air` - live-reloading wrapper.

`air -c air.conf`

Поменял подключение шаблонов, стал использовать `vfstemplate` из `shurcool/httpfs/html/`.

### Немного рефакторинга - 3 (static assets)

- [templates](week_10/photolist_frontend_templates.go)
- [assets](week_10/photolist_frontend_assets.go)
- [assets_gen](week_10/photolist_frontend_assets_gen.go)
- [main](week_10/photolist_frontend_main.go)

Встраивание статики в наш бинарник, чтобы фавиконки и прочее отдавать из бинарника а не из внешних файлов.
Проблема: air запускает бинарник из временного каталога, в котором нет нашего хранилища стат. файлов.
Решение: либо абсолютный путь к хранилищу, либо паковать внешние файлы вместе с бинарником.

Resources embedding.

На диске лежит два бинарника: dev, release. dev собирается без embedding, release собирается с embedding.
Ибо внутренние ресурсы программы лучше паковать внутрь программы (до некоторых пор).

Пакуются они через превращение в файлы go (`assets_vfsdata.go`), где ресурсы это слайсы байт.
Очевидно, такое решение годится только для маленьких ресурсов.

В файле ресурсов есть тег `// +build !dev`
чтобы сборка dev пользовалась внешними ресурсами.

В файле ассетов есть тег `// +build dev`. Так определяется, какой файл вливать в бинарник при сборке разных версий.

Генерация ресурсов выполняется очень запутанной процедурой, с использованием тегов `// +build ignore`, `// +build !dev`
в разных файлах.

Запускается генерация файла ресурсов через `go generate --tags=dev`

Не надо встраивать конфиги в бинарник (спасибо кэп).

Не надо встраивать шаблоны страниц сайта в бинарь, если разработка фронта отделена от разработки бэка.
Надо сделать hot-reload шаблонов в аппе, считывая их из хранилища.

### Проектирование API - 1 (схема данных, документация)

Веб-API
- Согласованность, все запросы-ответы в едином формате, стиле.
- Расширяемость, нет проблем с добавлением атрибутов, параметров, сущноcтей.
- Документация, должна быть, актуальная, автогенерированная + вручную написанные блоки.

Пример разных форматов:
- Список безымянных значений из разных доменов: очень плохо, нет структуры, нет типизации, нет самодокументируемости.
    Нет возможности удалить значение.
- Список словарей, лучше, но не сильно. Метаданные для ответа в целом вставить некуда, расширение структуры будет выглядеть чужеродно.
- Словарь вложенной структуры. Нелохо. Если разделить на метаданные и данные, будет отлично.

```json
{
    "meta": {},
    "data": {}
}
```

Никогда не отдавайте HTTP-status 200 если была ошибка.
Отдавайте 400 или 500.

Накрайняк, если хотите отделить транспорт от логики,
можно отдать HTTP-status 200 если была ошибка логики, но в ответе должно быть стандартное поле `status` с кодом ошибки.
Логировать эту ошибку надо через доп. заголовок. Т.е. код ошибки логики дублируется в заголовке и в теле ответа.

Документируйте публичные API в коде, генерируйте документацию. Используйте Swagger.
- schema-first
- from comments

Или protobuf + grpc, schema-first подход, когда в proto-файле всё описано.

Или GraphQL.

### Проектирование API - 2 (формат URL)

Какие URL следует использовать (формат), какие -- нет.
От cgi-bin программ, через php модули, через контроллеры запросов, через человеко-читаемые-урл, через REST HTTP verbs,
до `POST /api/v1/jrpc + JSON-RPC` или `POST /api/v1/gql + GraphQL`.

ЧЧУ: `/api/v1/articles/${slug}`.

Как передавать параметры?
- путь = метод, параметры = параметры. Путь должен однозначно определять сущность, для которой надо получить инфу.
- вариант REST: идентификатор зашивается в путь, `/api/v1/photos/${user_id}`. В Go такое сделать сложновато.
    Для реализации удобнее зашивать идентификатор в последнюю часть пути: `photo/comments/${photo_id}`.

Вот так лучше не надо: `photo/${photo_id}/comments/${comment_id}`, теряется понимание и согласованность.

Рекомендует в пути держать имя метода а параметры в query.
Как вариант, основной параметр идет последним элементом пути.

### Проектирование API - 3 (POST vs PUT)

Когда и зачем использовать POST, PUT.

POST: URI identifies the resource that will handle the enclosed entity.
PUT: URI identifies the entity enclosed with the request.

При использовании PUT всегда в пути должен быть идентификатор записи (в БД).
Создание или изменение записи контролируется клиентом.
`PUT /api/v1/photos`, создаст или отредактирует коллекцию фоток.

POST позволяет указать только эндпойнт, валидно: `POST /api/v1/photos`, создаст новую фотку, вероятно.

Для создания фотки удобнее POST, для изменения фотки удобнее PUT.

### Проектирование API - 4 (ajax)

- [handlers](week_10/ajax_handlers.go)
- [main](week_10/ajax_main.go)
- [token_middleware](week_10/ajax_token_middleware.go)
- [user](week_10/ajax_user.go)

Доработка app photolist.

Комментарии к фотографиям, владелец фотки, подписка на пользователя, рекомендованные пользователи.
Лента своих фоток, ленты других пользователей.

Все эти сущности добавлены с целью демонстрации (далее) некоторых деталей разработки.

Проверка CSRF-токен вынесена в мидлварь. Переделана работа с шаблонами.
Шаблон рендерится на параметре типа мапка-строка-интерфейс. Универсальная мапка, в котороую можно положить любые значения.
Метод `Render` структуры обработки шаблонов. Этот метод работает как мидлварь, добавляя в мапку нужные значения, типа csrf-token.

Проверка csrf-token вынесена в `CsrfTokenMiddleware`.
Все запросы на API будут проверять токен, наряду с теми, где еще не выполнена auth (login, reg).
Мимо проверки пролетают обычные запросы GET-не-апи.

Логин и почта это теперь два разных атрибута пользователя.

### Проектирование API - 5 (ajax, пояснения)

- [storage](week_10/ajax_storage.go)
- [httputils](week_10/ajax_httputils.go)
- [list.html](week_10/ajax_list.html)
- [list.js](week_10/ajax_list.js)

Разъяснение, как photolist теперь работает на AJAX (некоторые функции стали называться *API и дергаются скриптом из страниц).

Лента делает три запроса с серверу, чтобы получить страницу с фотками, список фолловеров и список рекомендаций.
Данные заливаются скриптом в div шаблона.

Дополнительный рефакторинг кода, с выносом формирования json ответов в отдельные методы.

Монструозный SQL запрос на получение фоток с комментариями и фолловерами. Надо будет переделывать.

В запросах нет лимитов на количество записей.

Вынос функций в API позволяет поддержать разных клиентов (мобилки, браузеры, ...) с разными требованиями к контенту.
Кому-то нужны комментарии, кому-то не нужны рекомендации, ...

## part 3, week 3 (11)

GraphQL
[Код, домашки, литература](week_11/materials.zip) https://cloud.mail.ru/public/DCe7/owQVvyqYD

### GraphQL - 1 (вводная)

Весь предыдущий рефакторинг (разделение на API и страницы, подгрузка фолловеров и рекомендаций отдельными запросами)
был нужен для демонстрации пользы GraphQL.

Клиенты разные, потребности у них разные (мобилки, браузер, ...). Нужно что-то гибкое, чтобы каждый мог показывать пользователю
только то, что требуется.

Много мелких запросов -- не совместимо с hiload. По каждому запросу надо проверить авторизацию, сессию, ...

Можно для каждого клиента делать свой эндпойнт, дорого и долго.

Поможет GraphQL: язык запросов к API.
- Describe your data: описывается схема данных и связи.
- Ask for what you want: спец.языком написали запрос только на то, что требуется.
- Get predictable results: json с запрошенными данными.

Пример схемы: https://developer.github.com/v4/object/repository/

Playground https://developer.github.com/v4/explorer/

Проблемы: сложность никуда не пропала.
Мы ее убрали из фронтэнда, предоставив инструмен получения нужных данных одним запросом.
Сложность ушла в бэкэнд, где нужно разбирать и выполнять этот запрос. Поддерживать гибкость.

### GraphQL - 2 (photolist graphql schema)

- [schema.graphql](week_11/gqlgen1_schema.graphql)

Как запустить серверную часть GraphQL на Go.

Рассмотрим схему
- В схеме восклицательный знак означает `not null`.
- Квадратные скобки означают `array`.
- Тип данных `ID` представлен строкой.
- Тип `Query` это чтение данных.
- Тип `Mutation` это запись данных.
- Метод (query) `user` требует параметр -- айди пользователя. Как и метод `photos`.
- В комментариях отмечено, как генерировать код по схеме.
- Есть еще тип `Subscription` для веб-сокет канала. Здесь не используется.

На примере плейграунд http://localhost/8080 демонстирует выполнение запросов.

Реализации:
- graphql-go/graphql на рефлексии, руками надо много писать
- 99design/gqlgen на кодогенерации (любимое), по схеме генерит заглушки

### GraphQL - 3 (gqlgen)

- [server](week_11/gqlgen2_server.go)
- [gqlgen.yml](week_11/gqlgen2_gqlgen.yml)
- [models_gen](week_11/gqlgen2_models_gen.go)
- [resolver](week_11/gqlgen2_resolver.go)
- [schema_alt.graphql](week_11/gqlgen2_schema_alt.graphql)

Обзор сгенерированного кода, см `gqlgen1` в материалах.

В каталоге со схемой `go run github.com/99designs/gqlgen init`

Получили сгенерированный по схеме
код, конфиг генератора, гошные структуры данных (модели).
Резолвер (хендлеры запросов) -- генерируется один раз и потом редактируется погромистом.
generated.go -- сам сервер, куча бойлерплейта, парсинг запросов и пр.

Некоторые подробности про конфиг генератора https://gqlgen.com/config
Как задать свои модели, которые уже есть в коде, например, структура пользователя в БД.
Инлайн директивы, которые можно добавить в схему для уточнения -- откуда генератор возьмет инфу и что с ней сделает.

### GraphQL - 4 (gqlgen2, resolver)

- [server](week_11/gqlgen2_server.go)
- [gqlgen.yml](week_11/gqlgen2_gqlgen.yml)
- [photo](week_11/gqlgen2_photo.go)
- [resolver](week_11/gqlgen2_resolver.go)

Добавление логики в сгенерированные в gqlgen1 заглушки.
Объяснение резолверов.

Rsolvers: входные точки обработки запросов.
В сервере добавлены заглушки с тестовыми данными.

В конфиге есть указание на структуру Photo но сказано, что User внутри Photo надо сгенерировать. Почему?
Чтобы сгенерировать код резолвера этой вложенной структуры.
В коде (DB) в Photo нет вложенной структуры User, тогда как в схеме gql есть.
Тут где-то магия превращения ссылки-по-id в записи БД в развернутую структуру, описанную в схеме.
Маппинг моделей базы в модели gql.

Обратите внимание, у модели (структура) есть методы по именам полей (getter).
Видимо, там эта магия (маппинг) и просходит.
Могла бы, если бы у модели была ссылка на БД. На таком, слишком низком, уровне мы не можем получить структуру User по
данным Photo без запроса к БД. Поэтому надо это делать уровнем выше, в резолверах запросов, где есть ссылки на хранилище.

Резолверы дают точки входа в обработку запросов.
Резолверы для чтения, записи, ...
Также резолверы есть на модели;
для резолвера Photo есть метод User для получения того самого вложенного в Photo пользователя (см.конфиг и схему).
Это тот самый сгенерированный резолвер, заказанный в конфиге.
Вот тут тоже маппинг DB => gqlschema работает.

По логу видно, резолвер User был вызван n+1 раз. Проблема: мы не ходим постоянно дергать базу, да еще и n+1 раз.

### GraphQL - 5 (dataloader)

- [server](week_11/gqlgen3_server.go)
- [userloader_gen](week_11/gqlgen3_userloader_gen.go)
- [resolver](week_11/gqlgen3_resolver.go)

Проблема n+1 запросов.
Можно создать огромную нагрузку на бэк.
Решение: батчевать запросы.

Вложенные структуры в схеме. Например, данные пользователя к каждой фотографии.
SQL запрос с джойном двух таблиц, жить можно.
GraphQL дергает сущности по одной.

Проблема известная, решается посредством https://github.com/vektah/dataloaden
кодогенератор загрузчиков данных.
По сути, выполнение серии запросов к примитиву в рамках одного пакетного запроса к хранилищу.

В резолвере, где нужно получить пользователя, вызывается `UserLoader.Load(...)`,
этот метод ждет некоторое время, ждет дополнительных вызовов этого метода, аккумулируюя запросы.
Потому уже весь пакет запросов выполняется в один заход.

Загрузка пользователей сделана через `UserLoaderMiddleware`, ибо нужен доступ к хранилищу, реф на которое в хандлере запросов.
Нужен доступ к айди текущего пользователя (получить фолловеров и рекомендации), через контекст.
Мидлварь создает конфиг лоадера данных но не делает обращений к БД, только готовит шаблоны запросов.
Конкретный обработчик запроса, при необходимости, дернет эти запросы.

Засада в том, что доступ к данным размазывается по абстрациям. Теперь обращение к БД есть мидлвари, не только в хранилище.

Дополнительно: загрузчик данных может работать не только с единичными обьектами, можно грузить списки (батч: слайс слайсов).

### GraphQL - 6 (gqlgen4, complexity)

- [queries.txt](week_11/gqlgen4_queries.txt)
- [generated](week_11/gqlgen4_generated.go)
- [server](week_11/gqlgen4_server.go)

Как можно сделать очень медленнй сервер GraphQL:
запрашивать (рекурсивно) внутрениие структуры, которые на самом деле получаются джойнами таблиц.
Например, для user сразу вместе с профилем пользователя, получить все его photo.
А для этих фото можно запросить данные пользователя, а для этих пользователей запросить фото, ...
Так можно всю БД выбрать в одном запросе.

Надо как-то ограничивать фантазию клиента, иначе он положит сервер.

Решается проблема с помощью параметров `ComplexityRoot..childComplexity`, которые аккумулируют значение сложности в запросах.

Для задания максимально допустимой сложности запроса в `handler.GraphQL` передается `ComplexityLimit(42)`.
Дополнительно, можно переопределить дефолтный способ вычисления сложности для методов.

Ограничения сложности определяются опытным путём, иногда трудно сразу определить, в какую цену встанет та или иная операция.

Всегда ограничивайте сложность, иначе мамкин хакер положит сайт.

### GraphQL - 7 (gqlgen4, params)

- [schema.graphql](week_11/gqlgen4_schema.graphql)
- [queries.txt](week_11/gqlgen4_queries.txt)

Добавляем параметры в запросы данных.

В схеме можно дать докстрингу для элемента, в тройных кавычках.
После чего, в playground можно пользоваться подсказками и вкладкой с генерированной документацией.

Возможность использовать именованные запросы, в которых определены параметры для передачи в селекторы данных.
Значения параметров для таких запросов задаются не в теле запроса а снаружи, в отдельном блоке.

Внутри тела запроса можно ссылаться на значения определенных рядом сущностей.

### GraphQL - 8 (gqlgen5, загрузка файлов)

- [resolver](week_11/gqlgen5_resolver.go)
- [schema.graphql](week_11/gqlgen5_schema.graphql)
- [server](week_11/gqlgen5_server.go)

Как загружать файлы на сервер, GraphQL.

`mutationResolver UploadPhoto`, `scalar Upload`
gqlgen предоставляет тип `Upload` для этого.

Плейграунд не поддерживает загрузку файлов, поэтому демонстрация будет через `curl`.
Демонстрация происходящего при загрузке текстового файлика в демо-хранилище.

Теперь все компоненты есть, для построения сервиса photolist на GraphQL.

### GraphQL - 9 (photolist 100_gqlben)

- [schema.graphql](week_11/100_gqlgen_schema.graphql)
- [user_repo](week_11/100_gqlgen_user_repo.go)
- [user](week_11/100_gqlgen_user.go)
- [main](week_11/100_gqlgen_main.go)

Начал внедрять GraphQL в аппу photolist.

Нужен рефакторинг. В таблице Photo есть (userID, userLogin), что противоречит схеме GraphQL.

Применил шаблон repository, где (`UserRepository`) абстрагировал операции с пользователем.
Изоляция бизнес-логики от логики хранения.
NB: ранее фото и сессия уже использовали этот шаблон, хотя никто и не заметил.

UncleBob: "DB is an IO device!"

В резолверах gqlgen лежат ссылки на репозитории, не на DB.

### GraphQL - 10 (gqlgen6 directive)

- [schema.graphql](week_11/gqlgen6_schema.graphql)
- [generated](week_11/gqlgen6_generated.go)
- [server](week_11/gqlgen6_server.go)

Директивы в GraphQL.
Позволяют сделать типа мидлварь для доступа к данным или аргументам.
Определить дополнительное поведение при обработке неких полей.

Два примера: на обработку результата и на обработку входных параметров.

В сгенерированном коде появился блок `Directives`, с определением функций, вызываемых при применении директив.
В реализации надо будет определить бизнес-логику этих врапперов.

Логика `isSubscribed`: нельзя получить фотки пользователя, на которого слиент не подписан.
Пример того, как можно разграничить доступ по ролям пользователей.

Реализация директив подставляется в конфиг в коде сервера.

Логика директивы `validation` использует параметр: список строк.
Валидация прикручена к комментариям загружаемой фотки `Mutation.uploadPhoto`.
Реализована валидация в методе `CheckValidation`.

### GraphQL - интеграция в проект - 1 (photolist 100_gqlgen backend)

- [schema.graphql](week_11/100_gqlgen_schema.graphql)
- [gqlgen.yml](week_11/100_gqlgen_gqlgen.yml)
- [XXX_graphql_models_gen](week_11/100_gqlgen_XXX_graphql_models_gen.go)
- [XXX_graphql_resolver](week_11/100_gqlgen_XXX_graphql_resolver.go)
- [main](week_11/100_gqlgen_main.go)
- [graphql_middleware](week_11/100_gqlgen_graphql_middleware.go)
- [graphql_resolver](week_11/100_gqlgen_graphql_resolver.go)

Интеграция сервера GraphQL в проект photolist (backend), в endpoint `/graphql`.

Пример сгенерированного с 0 кода.
Стартовая точка (main), подключение резолверов.
UserLoaderMiddleware.
Реализация резолверов.

Демонстрация загрузки фотки через curl.

### GraphQL - интеграция в проект - 2 (photolist 100_gqlgen frontend)

- [handlers](week_11/100_gqlgen_handlers.go)
- [list_gql.html](week_11/100_gqlgen_list_gql.html)
- [list_gql.js](week_11/100_gqlgen_list_gql.js)
- [schema.graphql](week_11/100_gqlgen_schema.graphql)
- [user_repo](week_11/100_gqlgen_user_repo.go)

Демо сайта photolist, где под капотом GraphQL.

Добавил шаблон для загрузки ленты через GQL.
В шаблоне подключается другой JS,

В JS больше всего изменений. See `function getUserPhotos`.
Все данные для рендеринга всей страницы получены одним запросом. Nice.

Обрати внимание на реализацию `function uploadPhoto`. ХитрО сделано , переменная`variables.file` задается через маппинг из поля `my_file`.

Подписанные пользователи и dataloader.
Даталоадер тут не используется, используется join в `LookupByIDs` методе репо.
Структура `User` с полем `Followed`, поле **указатель** на bool, чтобы отличать данные от null.
В итоге, имеем два способа загрузки пользователя из БД (даталоадером и подписками), отличающихся загрузкой этого булева значения.
Сделал херню и подпер костылем: демонстрация того, как надо тщательно следить за схемой, количеством запросов, согласованностью.

next: как разобрать получившуюся кашу из файлов кода в проекте?

### Организация пакетов в приложении - 1
### Организация пакетов в приложении - 2
### Организация пакетов в приложении - 3

## part 3, week 4 (12)

Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов
[Код, домашки, литература](week_12/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer
