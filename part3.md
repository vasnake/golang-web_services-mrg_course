# Разработка веб-сервисов на Golang. Часть 3:

- week 1, Структура приложения
- week 2, Проектирование API
- week 3, GraphQL
- week 4, Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов

## part 3, week 1 (09)

Структура приложения
[Код, домашки, литература](week_09/materials.zip) https://cloud.mail.ru/public/GzJG/nccMpqdzQ

### Структурируем приложение - 1 (вводная)

На примере цельного приложения `photolist` рассмотрим несколько важных тем.

### Структурируем приложение - 2 (описание прототипа и его проблем)

- [main](week_09/basic_main.go)
- [photos](week_09/basic_photos.go)

Начнем с прототипа, сляпанного из спагетти-кода. Чтобы сразу нарисовать целостную картину и декларировать проблемы, решаемые в следующих лекциях.

Главная программа, веб-сервис и модуль с утилитами для фоток.
Фунциональность: одна страница, на которой мы можем выбрать фотку для upload и видеть превьюхи уже загруженных фоток.

Три хандлера: `/`-list, `/upload`-upload, `/images/`-static_files.

Проблемы: глобальные переменные, не-потоко-безопасные; постоянный парсинг шаблона; нет авторизации;
файлы на диске сервера (вместо абстрактного хранилища);
вычитывание файлов для каждой превью, прямо при обработке запроса (должно быть через очередь, в воркерах);
код плохо разбит на модули и сложно тестировать.

### Структурируем приложение - 3 (распил на модули)

- [handlers](week_09/storage_handlers.go)
- [main](week_09/storage_main.go)
- [photos](week_09/storage_photos.go)
- [storage](week_09/storage_storage.go)
- [templates](week_09/storage_templates.go)

Разделение приложения на модули (файлы go).
На части разделился main: handlers, storage, templates.

При старте программы создается структура с инициализацией полей Storage, Templates.
Хендлеры страниц реализованы как методы этой структуры и пользуются этими полями, отвечающими некоторому нашему интерфейсу.

Шаблон теперь парсится один раз, при старте программы. Уже лучше.

Функциональность немного абстрагирована, разбита на модули и может быть протестирована.

### Структурируем приложение - 4 (add DB)

- [main](week_09/db_main.go)
- [db_init.sql](week_09/db_db_init.sql)
- [storage](week_09/db_storage.go)

Добавим БД `mysql` для поддержки постоянного хранения метаданных (списка загруженных файлов).
При создании структуры с данными сервиса мы кладем туда реф. на хранилище с тем-же интерфейсом но использующее БД.

Обсудили еще раз проблему глобальных переменных и их инициализации внутри фунции с помощью конструкции `db := createConnect(...)`:
тут не инициализируется глобальная переменная, тут создается новая локальная переменная.

### Тестируем комплексное приложение - 1 (sqlmock)

- [storage_test](week_09/db_storage_test.go)

Как тестировать логику, завязанную на запросы к БД.
Использовать драйвер к `sql.DB`: go-sqlmock.
Мокать запросы к БД.

### Тестируем комплексное приложение - 2 (gomock)

- [handlers](week_09/test_handlers.go)
- [handler_test](week_09/test_handler_test.go)

Как тестировать хендлер веб-страницы на примере `List`.
Сначала посчитали, сколько и каких кейсов тестирования надо: получение фоток (ок, ерр), заполнение шаблона (ок, ерр).
Сообразили, что нужен mock хранилища.

Поэтому: в данных сервиса реф. на хранилище меняем на реф. на интерфейс.
Потом в тесте подкладываем мок хранилища в код сервера и тестируем разные случаи.

По интерфейсу кодогенератор сделает обвязку, `mockgen ...`
В тестах используем её.

Upload handler будем мокать и тестировать тогда, когда абстрагируем хранилище и задействуем облако.

NB: интерфейс должен объявляться в том месте, где будет использоваться (где наиболее общий код).
Кроме случаев с интерфейсами общего назначения.
Почему? Направление зависимости в обратную сторону.
Реализация не должна объявлять этот интерфейс, просто реализовать заявленные методы.

### Авторизация и пароли - 1 (auth MVP)

- [db_init.sql](week_09/auth_db_init.sql)
- [templates](week_09/auth_templates.go)
- [main](week_09/auth_main.go)
- [session](week_09/auth_session.go)
- [index](week_09/auth_index.go)
- [user](week_09/auth_user.go)

Базовая версия подсистемы идентификации-авторизации.

Таблица с сессиями, таблица с пользователями. Для просмотра БД использует веб-морду Adminer.
Регистрация нового пользователя, выдача ему сессии-куки.

Появилась структура UserHandler.
Появились урлы (и хендлеры) login, logout, reg.
Завернул все урлы в AuthMiddleware через `/`.

Потом добавил статику `/images/`, получилось, что картинки отдаются мимо авторизации, ибо при маршрутизации сначала проверится
самый длинный путь (images) и дернется его обработчик, без авторизации.

Мидлварь авторизации проверяет, надо ли требовать наличия пользователя на данной странице.
На некоторых страницах пользователя может и не быть (e.g. регистрация нового пользователя).

Мапка, где значения это пустые структуры `struct{}`, не требует памяти под значения. Это set ключей.
Далее мидлварь достает сессию из БД или создает новую или вываливается с ошибкой.
Сессия добавляется в контекст и дергается downstream обработчик запроса, с передачей ему контекста.

Проверка наличия сессии в контексте используется в главной странице, при решении, куда направить пользователя: на страницу логина или в его ленту.

Обработка логина/регистрации, через БД.
Тонкости проверки/хранения пароля в след.видео.

### Авторизация и пароли - 2 (password hash)

- [user](week_09/auth_user.go)
- [pass](week_09/hashing_pass.go)

Как хешировать и хранить пароль.
Рандомная соль + функция хеширования.
Для одинаковых паролей получаем разные хеши.
Argon2 хорошая функция хеширования.

`hashedPass := argon2.IDKey([]byte(plainPassword), []byte(salt), 1, 64*1024, 4, 32)`

Пример с разными реализациями хеширования пароля.
Бенчмарк по скорости генерации пароля: чем медленнее, тем лучше, затрудняет брут-форс атаки.
Чем больше жрет памяти, тем лучше, труднее запустить на акселераторе.

### CSRF-токены (JWT для защиты от CSRF)

- [hash_token](week_09/csrf_token_hash_token.go)
- [crypt_token](week_09/csrf_token_crypt_token.go)
- [jwt_token](week_09/csrf_token_jwt_token.go)

JSON Web Tokens: безопасная передача токенов кросс-сайт. JWT.IO для проверки и де/кодирования JWT.
JWT в качестве CSRF-токенов.
Данные в токене открыты и доступны для просмотра. Защищены от изменения.

CSRF: Cross-Site Request Forgery.

Хеш токен просто хеширует массив байт, в котором зашиты sessID, userID. Потом туда добавляется tokenExpTime.

В крипто токене: структура с тремя полями превращается в json и этот текст шифруется.
Требуется защить эти данные от подделок (не от кражи).

JWT предлагает для защиты: контейнер с подписью. Данные открыты, но для их подмены надо как-то узнать ключ, которым подписан токен.
Этот ключ создается и используется на сервере, должен быть одноразовым и защищенным.

JWT токен состит из трех частей:
- заголовок: алгоритм, тип токена
- данные: json с нашими айдишками и временем жизни и временем выдачи токена
- подпись

Игрушечный пример со скользящими ключами, меняемыми на основе времени выдачи/устаревания.

### Сессии - 1 (рефакторинг сессий)

- [main](week_09/jwt_sess_main.go)
- [session_common](week_09/jwt_sess_session_common.go)
- [session_db](week_09/jwt_sess_session_db.go)
- [user](week_09/jwt_sess_user.go)

Рефакторинг кода сессий, с целью абстрагироваться от реализации.
С тем, чтобы потом воткнуть туда JWT токены.

Добавил менеджер сессий, класс с фабрикой.
Менеджер сессий добавлен как поле в структуру хендлеров страниц.
Используется в мидлварь авторизации и в обработке юзера.

Интерфейс менеджера сессий.

Реализация менеджера сессий на БД. Удаление всех сессий пользователя.

Создание пользователя и логин. Смена пароля пользователя.
Добавление атрибута `ver` к данным пользователя. Версионированность.

### Сессии - 2 (stateful vs stateless sessions)

Проблемы JWT в роли замены sessionID.

Аутентификация, stateful сессия, хранится в БД.
Недостаток: надо хранить в БД.
Преимущества: удобно, всё под рукой, любую сессию можно закрыть в любой момент.

Stateless сессия, на токенах (JWT).
В токене хранится не сессия а сразу (UserID, UserRoles).
В БД хранится только инфа по пользователю, сессия не нужна.

Проблемы.
Трудно отозвать сессию, только перевыпустив токен с датой устаревания в прошлом.
При этом умрут все сесии.
Нет надежного logout, при смене пароля не могу закрыть устаревшие сессии.
Нет полного списка сессий, нельзя видеть, кто еще (где) ходит от моего пользователя.

В целом, при отказе от сессий, либо трудно/невозможно выкинуть злоумышленника, либо пользователя постоянно выкидывает и ему надо перелогиниваться.

Как вариант, хранить в БД профиль пользователя а в токене передавать только (userID, userVersion).
Тогда, в профиле можно держать версию данных пользователя и испльзовать ее как признак смены сессии.
Такое, половинчатое решение.

https://www.google.com/search?q=stateless+sessions+JWT+problems+&client=safari&rls=en&ei=y0YgY56MGvCvrgSS6KewBA&ved=0ahUKEwjenfaBtJH6AhXwl4sKHRL0CUYQ4dUDCA0&uact=5&oq=stateless+sessions+JWT+problems+&gs_lcp=Cgdnd3Mtd2l6EAMyBQghEKABOgoIABBHENYEELADOgUIABCiBDoHCAAQHhCiBEoECEEYAEoECEYYAFCfDVjkOmCgPmgDcAF4AIABVIgB0wWSAQIxMZgBAKABAcgBCMABAQ&sclient=gws-wiz

### Сессии - 3

## part 3, week 2 (10)

Проектирование API
[Код, домашки, литература](week_10/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer

## part 3, week 3 (11)

GraphQL
[Код, домашки, литература](week_11/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer

## part 3, week 4 (12)

Сборка docker-контейнера, хранение файлов в S3, трейсинг запросов
[Код, домашки, литература](week_12/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer
