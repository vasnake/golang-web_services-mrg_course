# Разработка веб-сервисов на Go. Часть 2:

- week 1, Анатомия веб-сервиса
- week 2, SQL NoSQL
- week 3, Микросервисы
- week 4, Сервис в работе

## part 2, week 1

Анатомия веб-сервиса
[Код, домашки, литература](week_05/materials.zip) https://cloud.mail.ru/public/bjWY/TfQTzVMer

### Приветствие 1

Привет, будем галопом по веб-сервисам. Обзорно. Какие задачи встречаются при разработке веб-сервисов.

### Приветствие 2

Анатомия, компоненты веб-сервиса, которые так-или-иначе существуют в разных фреймворках:
- роутинг: отображение урлов (запросов) на функции
- авторизация/аутентификация/идентификация
- логирование
- обработка ошибок
- валидация входный параметров
- шаблонизация
- конфигурировние
- мониторинг
- миддлваре/фреймворки
- работа с IO device (БД, хранилища, очереди, etc.)

### Middleware 1 (wrappers)

- [middleware](week_05/middleware.go)

- Как мог бы выглядеть код миддлваре, если бы мы всё писали руками. Обработка паники, запись в лог, проверка авторизации, бизнес-логика.
Другой вариант: заворачивание хендлеров в "декораторы" middleware.
Middleware в данном случае это фунция handler => handler. Или ServerMux => ServerMux.
Аспект-ориентированое программирование.

### Middleware 2 (metrics using req.context)

- [context_value](week_05/context_value.go)

Используем Context (запроса) для реализации мидлвари, в которой вычисляются тайминги. Ценный пример мониторинга времени, уходящего на обработку запроса.
`req.Context()` как хранилище данных. Каждый вызов бизнес-логики завернут в декоратор, который, с использованием контекста,
вычисляет время, затраченное операцией. Потом миддлварь отсылает собранные в контексте данные в мониторинг, лог.
Перед выполением запроса контекст инициализируется, создается структура в которую будут собираться данные.
На выход навешивается defer, в котором подбиваются итоги. И вызывается бизнес-логика, в которой контекст будет обновляться при сборе данных мониторинга.

Значения в контексте не типизированные, компайл-тайм проверок нет. Поэтому -- очень осторожно и только если по другому нельзя!

Пустой интерфейс -- зло, реализовывать протоколы через них не надо, проверять и отлаживать очень сложно.
Как вариант -- сделайте свой контекст, с конкретными типами.

### Middleware 3 (errors)

- [basic_err](week_05/basic_err.go)
- [named_err](week_05/named_err.go)
- [own_err](week_05/own_err.go)
- [pkg_err](week_05/pkg_err.go)

Как лучше обрабатывать ошибки (в хендлерах запросов):
собрать и вывести информации побольше; трансформировать ошибку в ошибку с подробностями.

Еще лучше: типизированная ошибка. С помощью `errors.New()` создаются константы-ошибки для использования в коде.

Или создается новый тип данных, структура с расширенным описанием ошибки, для использования в качестве возвращаемого значения.
Достаточно реализовать интерфейс `Error() string` и можно пользоваться структурой как стандартной ошибкой.

Универсальный враппер ошибок сделан в `pkg/errors`. `errors.Wrap(...)`, `errors.Cause(err).(type)`, ...
А еще там есть вывод stacktrace.

### Роутеры 1 (gorilla, httprouter)

- [gorilla](week_05/gorilla.go)
- [httprouter](week_05/httprouter.go)
- [multiple](week_05/multiple.go)

`gorilla/mux`, мощный роутер, позволяет задать метод HTTP (POST, GET, ...), задать сложные правила матчинга не только по урл но и по другим параметрам запроса,
многое другое.
Один из самых медленных роутеров.

`HttpRouter`, вполне годная производительность (prefix-tree). Не такой мощный как горилла, сигнатура хендлеров не совместима с оригинальными гошными хендлерами.

Можно испльзовать разные роутеры в разных частях сервиса. Пример с использованием трех роутеров в одном сервисе.
Tradeoff: speed/power

### Роутеры 2 (fasthttp)

- [fasthttp](week_05/fasthttp.go)

`fasthttp` быстрый веб-сервер для Go. Уж если задумались о быстрых роутерах, почему бы не оптимизировать веб-сервер.
Использовать с `fasthttprouter`. Совсем другая сигнатура хендлеров.
Мутабельные структуры, вывод происходит после установки всех параметров. С горутинами будет сложно, ибо мутабельность.

### Валидация

- [validation](week_05/validation.go)

Нет стандартного способа валидации, всё проекто-зависимо.
Есть пакеты `asaskevich/govalidator`, `gorilla/schema`, ...
Это работает на рефлексии. Если надо, чтобы валидация работала быстрее, делайте кодогенератор или пишите руками.

### Фреймворки 1
### Фреймворки 2
### Логирование
### Веб-сокеты
### Шаблонизация
### Управление зависимостями
