# go-web_services-mrg_course

Golang course from MRG: [Разработка веб-сервисов на Golang](https://study.vk.team/learning/play/671)

Блоки программы. Часть 1:
- Введение в Golang
- Асинхронная работа
- Работа с динамическими данными и производительность
- Основы HTTP

## part 1, week 1

Введение в Go.
[Код, домашки, литература](week_01/materials.zip) https://cloud.mail.ru/public/pc7H/6Vx4txWWr

Зачем нужен еще один языка программирования?
Эффективность (работы стажёров в Гугл): компиляции, выполнения, разработки.
Утилизация многопроцессорных систем (легкие потоки, асинхронность);
Простой и понятный язык, читабельный, простая и быстрая сборка, с четким стилем.
Сборка в статический бинарник, решение проблемы dll-hell.

Для realtime, embedding не подходит (в наличии сборка мусора), но всё остальное OK.

### Первая программа

- https://play.golang.com/
- [run](run.sh)
- [hello_world](week_01/hello_world.go)

`package main`: основной (запускаемый) пакет программы.

`func main() {...}`: основной (запускаемый) функ. программы. Если такой нет, то запускатор будет ругаться
```s
go run hello_world.go
runtime.main_main·f: function main is undeclared in the main package
```

Как удобно в Scala, всё есть expression. Но в Golang не так, увы.

Используй `camelCase` для имён. Публичные обьекты называй с большой буквы `Println`.

### Переменные, базовые типы данных

- [vars_1](week_01/vars_1.go)
- [vars_2](week_01/vars_2.go)
- [strings](week_01/strings.go)
- [const](week_01/const.go)
- [types](week_01/types.go)
- [pointers](week_01/pointers.go)

`var name type` создает переменную со значением "по умолчанию";
считается достижением, что не бывает неопределенных значений, всегда память (выделенная под переменную) инициализируется.

`var name = 42` создает переменную с типом, выведенным автоматом из данного значения.

`name := 42` короткая форма создания новой переменной.

`name1, name2 = 42, 37` множественное присваивание (инициализация) работает.

[Почему нет префиксного инкремента?](https://go.dev/doc/faq#inc_dec)
> Why are ++ and -- statements and not expressions? And why postfix, not prefix?

Without pointer arithmetic, the convenience value of pre- and postfix increment operators drops.
By removing them from the expression hierarchy altogether, expression syntax is simplified and
the messy issues around order of evaluation of ++ and -- (consider f(i++) and p[i] = q[++i]) are eliminated as well.
The simplification is significant

`var i int` разрядность зависит от платформы.
Можно указать явно, `int8, int16, int32, int64`.
Аналогично `uint`.

`float32, float64` нет просто `float`.

Есть `complex64, complex128` математики и физики радуются.

Строки в кавычках интерпретируются, символы типа `\n` и прочие будут транслированы.

Строки в бэктиках не интерпретируются.

Одинарные кавычки для задания byte (uint8) или rune (uint32).

Строки immutable.

Длина строки считается в байтах. Для подсчета в символах используй `utf8.RuneCountInString(someStr)`.
Соответственно, срезы тоже в байтах.
Строки можно легко конвертировать в байты и байты в строки.

Константы `const name = value`.
Блоки констант.
Опредение через `iota`, автоинкремент, всё сложно.
Нетипизированные константы, тип присваивается при записи константы в переменную. Вроде макроса получается.

Пользовательские типы данных, `type`. Полезно при моделировании, DSL.
Нет автоматического приведения типов.

Нет адресной арифметики, но есть ссылки, reference. Полезно для передачи структур без копирования.
- `b := &a` получение ссылки.
- `*b = 42` запись значения по ссылке.
- `c := new(int)` создание ссылки на безымянную переменную.

### Переменные, составные типы данных

- [array](week_01/array.go)
- [slice_1](week_01/slice_1.go)
- [slice_2](week_01/slice_2.go)
- [map](week_01/map.go)

`var arr3 [3]int` размерность массива входит в определение типа переменной, массивы разных размерностей не совместимы по типам.

Для определения размера массива можно использовать константы, но нельзя переменные.

`arr3 := [...]int{1, 2, 3}` Размер массива можно не задавать при явной инициализации.

При выходе за границы массива в рантайме получаем панику.

По причине несовместимости типоразмеров массивов, на практике работа с массивами вынесена на нижний уровень.
Сверху, то чем пользуются прикладники -- срезы, slice.

- `var buf []int` создание пустого слайса без инициализации
- `buf := []int{} // len:0, cap:0` создание пустого с инициализацией
- `buf := make([]int, 5, 10) // len:5, cap:10` срез это некий буфер, у него есть длина и емкость.

- `buf = append(buf, 9, 10) // len:2, cap:2` буфер может расти, при исчерпании емкости буфер пересоздается с удвоенной емкостью.
- `buf = append(buf, otherBuf...)` при добавлении другого буфера, его надо "распаковать".

Слайсы могут работать "по ссылке", оперируюя значениями в одном и том-же буфере.
То есть, если явно не выделять память под слайс (или неявно, через append), то работа идёт в одном и том-же буфере.

- `numCopied = copy(emptyBuf, buf)` копирование элементов в другой буфер, внутри проверка на выход за границы.
- `copy(buf[1:3], []int{5, 6})` копирование под-диапазона.

Мапки `var user map[string]string`, можно, как и слайс, создать с нужной ёмкостью, через `make`
- `mName, mNameExists := user["middleName"]` правильный способ получения значения из мапки, ибо по умолчанию, несуществующее значение = пустая строка.
- `delete(user, "lastName")` удаление ключа

### Управляющие конструкции

- [control](week_01/control.go)
- [loop](week_01/loop.go)

- `if boolVal { ... }` только тип bool.
- `if v, exists := myMap["name"]; exists { ... }` условие с блоком инициализации
- `switch len(myMap) { 	case 0, 1: ... }` по умолчанию делает break при срабатывании условия
- `switch ... case k == "name" && v == "Bender": ...` сложные условия в switch
- `switch ... break` оператор выхода, можно выходить через несколько уровней, по метке

Циклы определяются ключевым словом `for`, есть разные формы.

`for pos, symb := range myStr { ... }` итерирование строки делается по символам, не байтам.

### Основы функций

- [functions](week_01/functions.go)

`func sqrt(x int) int { ... }` и несколько более сложных вариантов объявления.
Например, именованный возвращаемый результат, иногда бывает удобно.

`func namedWithError(condition bool) (res int, err error) { ... }` осторожнее с значениями "по умолчанию".

`func sum(in ...int) int { ... }` кортежи параметров и кортежи возвращаемых значений -- это нормально.

Переменное количество входных параметров базируется на представлении параметров как слайса.

### Функция как объект первого класса, анонимные функции

- [firstclass](week_01/firstclass.go)

Функция как значение переменной -- присваивать, передавать, возвращать.

`printer := func(msg string) { ... }` анонимная функция как значение переменной.

### Отложенное выполнение и обработка паники

- [defer](week_01/defer.go)
- [recover](week_01/recover.go)

- `defer doStuff("after work ...")` будет вызвана перед выходом из области видимости. Полезно как код финализации процедур.
- Несколько defer складываются в стек (FILO).
- Аргументы отложенных функций вычисляются НЕ отложенно а сразу. Чтобы этого избежать, такие аргументы заворачиваются в анонимную функцию.

defer полезен при восстановлении из паники.
Если внутри defer вызвать `recover()`, то программа не вывалится в панику а продолжит работать штатно.

### Основы работы со структурами

- [structs](week_01/structs.go)

`type Person struct { Id int ... }` поля могут быть любых типов.

Полный формат инициализации структуры `var acc Account = Account{Id: 42, ... }`
с использованием имён полей. При пропуске поля -- его значение будет "по умолчанию".

Краткая форма инициализации `acc.Owner = Person{33, "Foo Bar", "Under The Bridge"}`
без имён полей, но пропускать поля уже нельзя.

Композиция структур: встраивание полей одной структуры в namespace другой структуры (подробнее см. код).
При конфликте имён, выигрывает поле вышележащее в иерархии вложенности.

### Методы структур

- [methods](week_01/methods.go)

Метод: функция, привязанная к типу данных.
Особенность языка: нет необходимости определять методы при определении типа. Можно привязать метод к типу когда угодно.

`func (p *Person) SetName(newName string) { p.Name = newName }` N.B. структура должна быть передана by-reference в методах-сеттерах.
Иначе метод будет применяться к копии объекта.
Язык не требует явного указания передачи by-reference при вызове метода, достаточно того, что by-reference указан в определении метода.

При композиции структур, внешняя структура получает все методы встроенных структур.

### Пакеты и область видимости

- [dir.txt](week_01/dir.txt)
- [visibility/main](week_01/visibility/main.go)
- [visibility/person/person](week_01/visibility/person/person.go)
- [visibility/person/func](week_01/visibility/person/func.go)

```s
# visibility
|---person
|   |---person.go
|   |---func.go
|---main.go

```

> As of Go v1.13, by default, go modules are used.
> Therefore, you need to tell explicitly if you don't want to do this. `GO111MODULE=off go run main.go`

GOPATH определяет корневую директорию, в которой будут под-директории `bin, pkg, src`.

Имя пакета это имя директории.
Приватные поля определяются именованием с маленькой буквы, публичные поля -- с большой.

Доступ к приватным полям возможен только в коде пакета, где определено приватное поле.

Крупные пакеты, с большим количеством файлов, предпочтительнее мелких пакетов, с малым количеством файлов.

Зависимости складываются в директории vendor.

### Основы работы с интерфейсами

- [basic](week_01/basic.go)
- [many](week_01/many.go)
- [cast](week_01/cast.go)

- Интерфейс это тип `type Payer interface { Pay(int) error }`
- Другой тип может содержать реализацию интерфейса `func (w *Wallet) Pay(amount int) error { ... }`
- При вызове похер на тип, указываем интерфейс `func Buy(p Payer) {	err := p.Pay(10) }`

Можно (нужно?) держать переменную (поле структуры) с типом нужного интерфейса `var p Payer; p = &Card{Balance: 100}`

Можно кастовать тип от интерфейса обратно к конкретному типу, предварительно сматчив тип.

Так реализуется полиморфизм. Добавил реализацию интерфейса в произвольный тип и радуйся.

Неясно, как, глядя на код, сразу сказать, кто реализует какой интерфейс и в каком объеме.

### Пустой интерфейс

- [empty_1](week_01/empty_1.go)
- [empty_2](week_01/empty_2.go)

Пустой интерфейс (type, value) не накладывает ограничений. Использовать его можно только если ручками делать проверку/приведение типа:
`func Buy(in interface{}) { if p, ok = in.(Payer) ...}`

Рассказал на примере `fmt.Printf`, как аргумент типа "пустой интерфейс" может быть подерган за разные методы (опции форматирования определяют вызываемый метод).

### Композиция интерфейсов

- [embed](week_01/embed.go)

Как и структуры, интерфесы могут быть составлены из других интерфейсов.
При этом, как и структуры, охватывающий интерфейс включает методы вложенных интерфейсов.

### Написание Программы Уникализации (ПУ)

- [uniq](week_01/uniq.go)
- [data_map.txt](week_01/data_map.txt)

Пример программы: получает на вход файл и выводит только уникальные строки из этого файла.

Два варианта: на мапке строка - уникальность; на предположении, что файл сортирован (prev == current).

### Написание тестов для ПУ

- [unique/unique](week_01/unique/unique.go)
- [unique/unique_test](week_01/unique/unique_test.go)

Чтобы поддерживать тестирование, зависимости передаются в функцию как аргументы
`func sortedInputUnique(input io.Reader, output io.Writer) error { ... }`

Модуль тестов должен быть файлом с именем с суффиксом `_test.go`.
Должен содержать функции-тесты с именами с префиксом `Test`:
`func TestSortedInput(t *testing.T) { ... }`

Тесты запускаются `go test -v ./unique`

## part 1, week 2

Асинхронная работа.
[Код, домашки, литература](week_02/w2_materials.zip) https://cloud.mail.ru/public/YDEX/Dau2wVWuw/

### Методы обработки запросов и плюсы неблокирующего подхода

Асинхронное выполнение (AJAX),
скорость потока данных процессор-кеш-память, время на переключение контекста (выгрузка-загрузка регистров),
современные тенденции на многоядерность и параллельность,
тяжелые процессы, потоки легче, асинхронные сопрограммы (green threads) еще легче.

Утилизация дорогого железа -- сервер должен работать.

Невытесняющая многозадачность (eventloop, Windows 3.0) vs preemptive.

Ввод-вывод и ожидание возврата из syscall. Время ожидания можно потратить на другие задачи, non-blocking IO.
IO-bound vs CPU-bound.

`Communicating Sequential Processes` by Tony Hoare. Горутины перемещаются между системными потоками,
код горутины может быть выполнен в любом потоке (как перемещается стек?).

### Горутины -- легковесные процессы

- [goroutines](week_02/goroutines.go)

`go doSomeWork(i)` функция не может вернуть значение обычным способом (см. каналы).

`runtime.Gosched()` уйти в планировщик, дав возможность запустить другие горутины, yield.

Есть шанс заблокировать шедулер, если молотить цикл без вызовов системных функций.

### Каналы -- передаём данные между горутинами

- [chan_1](week_02/chan_1.go)
- [chan_2](week_02/chan_2.go)

`chan` keyword. Передача контроля над данными между потоками/горутинами.

`ch1 := make(chan int)` небуферизованный канал.
`ch1 <- 42` запись в канал, читатель уже должен ждать, ибо небуферизовано.
`v := <-in` чтение из канала.

Чтение, запись -- операторы стрелочка `x <- myChannel; myChannel <- x`.

Небуферизованные каналы vs буферизованные, размер буфера. Работа с каналом в цикле.

Если писать в небуферизованый канал, из которого никто не читает, будет deadlock, очень плохо.
Наоборот тоже беда, нельзя читать из канала, в который никто не пишет.

Похоже, что система отслеживает закрытие горутины, связанной с каналом и повисший канал вызывает ошибку.

Записанное в буферизованный канал может пропасть без следа, если никто не прочтёт.

Эти проблемы позволяет решить оператор `select` ...

### Мультиплексирование каналов через (не блокирующий) оператор `select`

- [select_1](week_02/select_1.go)
- [select_2](week_02/select_2.go)
- [select_3](week_02/select_3.go)

`select { case val := <-ch1: ...; case ch2 <- 1: ...; default: ... }`
Что-то делает только если канал готов. Если все каналы остановлены, то действие "по умолчанию".

Выбор в цикле, действие по умолчанию если ни один канал не работоспособен -- можно выходить из цикла.

Использование канала "команд" вместе с каналом "данных".

### Таймеры и таймауты (как источник сигнала в каналах)

- [timeout](week_02/timeout.go)
- [tick](week_02/tick.go)
- [afterfunc](week_02/afterfunc.go)

- Таймер как источник сигнала "через определенное время". Реализация тайм-аут логики.
- Тикер как источник регулярных/периодических сигналов в канале.
- AfterFunc как способ отложенного выполнения функции.

Некоторые фунции пакета time могут быть удобны, но приводить к утечкам памяти, создавая вечные таймеры.

### Пакет `context` и отмена выполнения

- [cancel](week_02/context_cancel.go)
- [timeout](week_02/context_timeout.go)

Отмена асинхронных операций, вручную.
Всем воркерам выдается общий контекст `ctx, finish := context.WithCancel(context.Background())`, в котором определена фунция завершения.
Когда получен нужный результат, дергается функция завершения контекста и воркеры понимают (слушая канал `ctx.Done()`), что пора выходить.

Отмена по таймауту `ctx, _ := context.WithTimeout(context.Background(), workTime)`.
В канал `ctx.Done()` приходит сообщение по таймеру, не по ручному вызову функции завершения.

Контекст -- основной способ отмены асинхронных операций, завершения воркеров, выполняющих циклы или долгие операции асинхронно.

### Асинхронное получение данных

- [async_work](week_02/async_work.go)

Практическое применение горутин и каналов: распараллеливание считывания статей и комментариев к ним на сайте.

### Пул воркеров

- [workerpool](week_02/workerpool.go)

Один канал как очередь сообщений, несколько горутин как воркеры читающие из очереди. Главная программа сыпет задания в очередь.

### `sync.Waitgroup` -- ожидание завершения работы

- [waitgroup](week_02/waitgroup.go)

До сих пор использовали ввод с клавиатуры, чтобы программа не завершилась раньше своих воркеров. Теперь так делать не нужно.

Ресурс `wg := &sync.WaitGroup{}`, увеличивается `wg.Add(1)` при добавлении воркеров и уменьшается `defer wg.Done()` при удалении воркеров.
Можно использовать для ожидания `wg.Wait()` завершения всех воркеров.

### Ограничение по ресурсам

- [ratelim](week_02/ratelim.go)

Использование буферизованного канала как ограничителя. Как буфер исчерпался, новая работа не поступает.
Перед стартом работы, воркер пытается записать сообщение в канал квоты. Если в буфере место ещё есть, воркер запишет
сообщение и сможет продолжить работу.
На выходе воркер считывает сообщение из канала квоты, освобождая место в буфере.

### Ситуация гонки на примере конкурентной записи в map

- [race_1](week_02/race_1.go)

Пять воркеров конкурентно пишут в одну мапку. Мапка по ходу операций перестраивается и разные воркеры начинают работать с разными копиями данных.
Кто из них победит? Программа падает с fatal error.

`go run -race ...` для диагностики.

Что же делать?  Ставить блокировки, ...

### `sync.Mutex` для синхронизации данных

- [race_2](week_02/race_2.go)

Берем мютекс `mu := &sync.Mutex{}` и в нужном месте используем его
`mu.Lock(); counters[th*10+j]++; mu.Unlock()`

Но есть нюансы ...

### `sync.Atomic`

- [atomic_1](week_02/atomic_1.go)
- [atomic_2](week_02/atomic_2.go)

Для атомарного изменения одной переменной (регистра ЦП) использовать Mutex слишком дорого.
Есть альтернатива `atomic.AddInt32(&totalOperations, 1)`.

## part 1, week 3

Работа с динамическими данными и производительность
[Код, домашки, литература](week_03/part1_week3.zip) https://cloud.mail.ru/public/2iXh/RC437wn11

### Распаковываем JSON

- [json](week_03/json.go)
- [struct_tags](week_03/struct_tags.go)

- Пакет `encoding/json` дает нам кодек.
Декодирование из слайса байт в структуру (надо знать тип структуры и создать её, пустую, перед декодированием) `json.Unmarshal(bytes, emptyStructRef)`
- Кодирование зеркально, `bytes, err := json.Marshal(someStruct)`.
- Приватные поля (с маленькой буквы которые) не обрабатываются, ибо `encoding/json` пакет не может получить доступ к приватным полям нашего пакета `main`.

Теги структуры -- метаинформация структур. При описании (определении) стурктуры, к полю добавляется строка определенного формата,
где записана метаинформация. В частности, как декодеру json обрабатывать поле, какое имя ему дать, какой тип использовать, etc.

```s
ID       int `json:"user_id,string"`
```

### Нюансы работы с JSON

- [dynamic](week_03/dynamic.go)

Как быть, если мы точно не знаем структуру, представленную json текстом?
Unmarshal в пустой интерфейс.

Также и Marshal, создав мапку `map[string]interface{}{ ... }`, можно ее кодировать в json.

### Пакет reflect -- работаем с динамикой в рантайме

- [reflect_1](week_03/reflect_1.go)
- [reflect_2](week_03/reflect_2.go)

- `reflect.ValueOf(x).Elem()` позволяет итерировать типы и значения из которых состоит "пустой интерфейс".
- Пример, как при помощи рефлексии распаковать слайс байт (бинарные данные на выходе perl `pack`) в структуру.
`reflect.ValueOf(x).Elem()` для получения списка полей структуры, которую надо восстановить из слайса байт.
Перебирая поля структуры, читаем данные из источника байт.

### Кодогенерация -- программа пишет программу

- [unpack](week_03/unpack.go)
- [marshaller](week_03/marshaller.go)
- [codegen](week_03/codegen.go)

К структуре добавлен метод `Unpack`, сгенерированный кодогенератором.
Метод реализует восстановление структуры из бинарных данных, созданных через perl `pack`.
Кодогенератор анализирует гошную структуру (пользуясь гошным AST), считанную из файла с исходником,
и, для всех её полей, создает код восстановления поля из слайса байт.

Кодогенерация полезна, когда некогда в рантайме тратить время на анализ и рефлексию. Профилирование покажет насколько падает скорость ...

### Система бенчмарков Go

- [unpack_test](week_03/unpack_test.go)
- [json_test](week_03/json_test.go)
- [string_test](week_03/string_test.go)
- [prealloc_test](week_03/prealloc_test.go)

Бенчмарки в `testing.B`, `func BenchmarkFooBar( ... ) { ... }`, `go test -bench ...`

Распаковка структуры через кодогенерацию вдвое быстрее рефлексии.

`go test -bench . -benchmem unpack_test.go` замер расхода памяти. Рефлексия жрет вдвое больше памяти.

Пакет кодека json на кодогенерации, EasyJson, в 4 раза эффективнее стандартного.

Демонстрация медленности регулярных выражений на строках. На порядок.

Демонстрация медленности добавления в слайс без преаллокации. В 20 раз медленнее.

### Профилирование через pprof

Собрать профиль
`go test -bench . -benchmem -cpuprofile=cpu.out -memprofile=mem.out -memprofilerate=1 unpack_test.go`

Анализ профиля
`go tool pprof main.test.exe mem.out`

Команды: `top`, `list Unpack`, `web`, `alloc_space, top`, `alloc_objects, top`

Можно снимать дампы с работающей программы, не прерывая её работы.

### sync.Pool

- [pool_test](week_03/pool_test.go)

Хотим не выделять память каждый раз, хотим использовать пул преаллоцированной памяти. Для скорости.

`dataPool = sync.Pool{ ... }; data := dataPool.Get().(*bytes.Buffer)`

Процентов 10 скорости выиграли. Операций выделения памяти на порядок меньше. Нагрузка на GC, соответственно, падает драматически.

### Покрытие кода тестами

`go test -v -cover`,
`go test -coverprofile=cover.out`,
`go tool cover -html=cover.out -o cover.html`

### XML

- [main](week_03/xml_main.go)
- [xml_test](week_03/xml_test.go)

Поточная обработка данных, на примере xml. `encoding/xml`.
`xml.NewDecoder(bytes.NewReader(data)).Token()` читаем по токенам, обрабатываем.

## part 1, week 4

Основы HTTP
[Код, домашки, литература](week_04/w4_materials.zip/) https://cloud.mail.ru/public/NTFa/barMiVYZd

Слушаем TCP-сокет с использованием пакета net
Обслуживание HTTP-запросов
Работа с параметрами запросов
Обслуживание статичных данных
Загрузка файлов формы
HTTP-запросы во внешние сервисы
Тестирование HTTP-запросов и ответов
Inline-шаблоны и шаблоны из файлов
Вызов методов и функций из шаблонов
Профилирование через pprof
Поиск утечки горутин
Трассировка поведения сервиса
Пример с telegram-ботом

## Info, links

- `Communicating Sequential Processes` by Tony Hoare
- https://cs.stanford.edu/people/eroberts/courses/soco/projects/2008-09/tony-hoare/csp.html
- http://www.usingcsp.com/cspbook.pdf
- CSP vs Actor model
- [If a map isn’t a reference variable, what is it?](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it)
